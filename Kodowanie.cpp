#include <string>
#include <iostream>
#include <fstream>
#include <iomanip>

using namespace std;

enum KODOWANIA {
	BRAK	= 0,
	ISO8859	= 1,
	WIN1250	= 2,
	CP852	= 4,
	UTF8	= 8,
	MAZOVIA	= 16
};

typedef unsigned char BYTE;

const int ROZMIAR_BUFORA = 4096;

typedef BYTE BUFOR[ROZMIAR_BUFORA];

struct BUFOR_CTRL_STRUCT {
	string nazwapliku;
	ifstream input;
	BUFOR bufor;
	// index znaku do odczytu; idxznak<=idxostatniznak
	int idxznak;
	// index ostatniego znaku w buforze; 0<=idxostatniznak<4096
	int idxostatniznak;
};

typedef struct BUFOR_CTRL_STRUCT BUFOR_CTRL;

BYTE map_iso2win1250(BYTE znak)
{
	const BYTE iso2win1250[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* A */0x00, 0xA5, 0x00, 0xA3, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0xAF,
	/* B */0x00, 0xB9, 0x00, 0xB3, 0x00, 0x00, 0x9C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0xBF,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0xD1, 0x00, 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0xF1, 0x00, 0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = iso2win1250[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else
		return znak;
}

BYTE map_iso2cp852(BYTE znak)
{
	const BYTE iso2cp852[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* A */0x00, 0xA4, 0x00, 0x9D, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0xBD,
	/* B */0x00, 0xA5, 0x00, 0x88, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0xBE,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0xE3, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0xE4, 0x00, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = iso2cp852[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_iso2mazovia(BYTE znak)
{
	const BYTE iso2mazovia[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* A */0x00, 0x8F, 0x00, 0x9C, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xA1,
	/* B */0x00, 0x86, 0x00, 0x92, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0xA7,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0xA5, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0xA4, 0x00, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = iso2mazovia[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_win12502iso(BYTE znak)
{
	const BYTE win12502iso[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0xAC,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB6, 0x00, 0x00, 0xBC,
	/* A */0x00, 0x00, 0x00, 0xA3, 0x00, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF,
	/* B */0x00, 0x00, 0x00, 0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBF,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0xD1, 0x00, 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0xF1, 0x00, 0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = win12502iso[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_win12502cp852(BYTE znak)
{
	const BYTE win12502cp852[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x8D,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0xAB,
	/* A */0x00, 0x00, 0x00, 0x9D, 0x00, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD,
	/* B */0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBE,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0xE3, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0xE4, 0x00, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = win12502cp852[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_win12502mazovia(BYTE znak)
{
	const BYTE win12502mazovia[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0xA0,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0xA6,
	/* A */0x00, 0x00, 0x00, 0x9C, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1,
	/* B */0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0xA5, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0xA4, 0x00, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = win12502mazovia[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_cp8522iso(BYTE znak)
{
	const BYTE cp8522iso[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0xB3, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x00, 0xC6,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0xB6, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00,
	/* A */0x00, 0x00, 0xF3, 0x00, 0xA1, 0xB1, 0x00, 0x00, 0xCA, 0xEA, 0x00, 0xBC, 0x00, 0x00, 0x00, 0x00,
	/* B */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0xBF, 0x00,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0xD3, 0x00, 0x00, 0xD1, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = cp8522iso[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_cp8522win1250(BYTE znak)
{
	const BYTE cp8522win1250[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0xB3, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0xC6,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0x9C, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00,
	/* A */0x00, 0x00, 0xF3, 0x00, 0xA5, 0xB9, 0x00, 0x00, 0xCA, 0xEA, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x00,
	/* B */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0xBF, 0x00,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0xD3, 0x00, 0x00, 0xD1, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = cp8522win1250[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_cp8522mazovia(BYTE znak)
{
	const BYTE cp8522mazovia[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x95,
	/* 9 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x00, 0x00,
	/* A */0x00, 0x00, 0xA2, 0x00, 0x8F, 0x86, 0x00, 0x00, 0x90, 0x91, 0x00, 0xA6, 0x00, 0x00, 0x00, 0x00,
	/* B */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 0xA7, 0x00,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0xA3, 0x00, 0x00, 0xA5, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = cp8522mazovia[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_mazovia2iso(BYTE znak)
{
	const BYTE mazovia2iso[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0xA1,
	/* 9 */0xCA, 0xEA, 0xB3, 0x00, 0x00, 0xC6, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 0xA3, 0x00, 0xB6, 0x00,
	/* A */0xAC, 0xAF, 0xF3, 0xD3, 0xF1, 0xD1, 0xBC, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* B */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = mazovia2iso[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

BYTE map_mazovia2win1250(BYTE znak)
{
	const BYTE mazovia2win1250[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0xA5,
	/* 9 */0xCA, 0xEA, 0xB3, 0x00, 0x00, 0xC6, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x9C, 0x00,
	/* A */0x8F, 0xAF, 0xF3, 0xD3, 0xF1, 0xD1, 0x9F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* B */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = mazovia2win1250[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}
	
BYTE map_mazovia2cp852(BYTE znak)
{
	const BYTE mazovia2cp852[128]={
		/*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
	/* 8 */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x00, 0xA4,
	/* 9 */0xA8, 0xA9, 0x88, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x9D, 0x00, 0x98, 0x00,
	/* A */0x8D, 0xBD, 0xA2, 0xE0, 0xE4, 0xE3, 0xAB, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* B */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* C */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* D */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* E */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* F */0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	BYTE mapznak;

	if(znak>=0x80){
		mapznak = mazovia2cp852[znak-0x80];
		if(mapznak==0x00)
			return znak;
		else
			return mapznak;
	} else return znak;
}

void przekoduj_plik(const string zrodlowyplik, enum KODOWANIA kodowanie)
{
	const string docelowyplik = "przekodowany.txt";
	ifstream inputfile;
	ofstream outputfile;
	//
	inputfile.open(zrodlowyplik.c_str(), ios::in|ios::binary);
	if (!inputfile) {
		cerr << "B³¹d otwarcia pliku: " << zrodlowyplik << endl;
		//exit(1);
		return;
	}
	outputfile.open(docelowyplik.c_str(), ios::out|ios::binary);
	if (!outputfile) {
		cerr << "B³¹d otwarcia pliku: " << docelowyplik << endl;
		//exit(1);
		return;
	}
	//
	char znak;
	while (inputfile.get(znak)) {
		BYTE mapznak;
		switch (kodowanie) {
			case WIN1250:
				mapznak = map_iso2win1250(znak);
				break;
			case CP852:
				mapznak = map_iso2cp852(znak);
				break;
			case UTF8:
			case MAZOVIA:
				mapznak = znak;
				break;
		}
		outputfile.put(mapznak);
	}
	//
	outputfile.close();
	inputfile.close();
}

int bufor2_otworz(BUFOR_CTRL& buforctrl, const string nazwapliku)
{
	if (buforctrl.input.is_open())
		return 1;
	buforctrl.nazwapliku = nazwapliku;
	// otwieramy plik: wejsciowy, binarny
	buforctrl.input.open(buforctrl.nazwapliku.c_str(), ios::in|ios::binary|ios::ate);
	if (!buforctrl.input)
		return 2;
	// ustaw sie na poczatku pliku
	buforctrl.input.seekg(0, ios::beg);
	// index bufora na 0 - pusty bufor
	buforctrl.idxostatniznak = 0;
	// index znaku do odczytu na 0
	buforctrl.idxznak = 0;
	// wszystko ok
	return 0;
}

int bufor2_zamknij(BUFOR_CTRL& buforctrl)
{
	buforctrl.input.close();
	return 0;
}

bool bufor2_eof(BUFOR_CTRL& buforctrl)
{
	// EndOfFile jest true jesli odczytany plik ma eof i z bufora odczytany ostatni znak
	return buforctrl.input.eof()&&(buforctrl.idxznak==buforctrl.idxostatniznak);
}

int bufor2_napoczatek(BUFOR_CTRL& buforctrl)
{
	if (!buforctrl.input.is_open())
		return 3;
	buforctrl.input.clear();
	// ustaw sie na poczatku pliku
	buforctrl.input.seekg(0, ios::beg);
	// index bufora na 0 - pusty bufor
	buforctrl.idxostatniznak = 0;
	// index znaku do odczytu na 0
	buforctrl.idxznak = 0;
	return 0;
}

BYTE bufor2_wezbajt(BUFOR_CTRL& buforctrl)
{
	BYTE znak;
	if ((buforctrl.idxostatniznak==0)||(buforctrl.idxznak==buforctrl.idxostatniznak)) {
		buforctrl.input.read((char *)buforctrl.bufor, ROZMIAR_BUFORA);
		buforctrl.idxostatniznak = buforctrl.input.gcount();
		buforctrl.idxznak = 0;
	}
	znak = buforctrl.bufor[buforctrl.idxznak++];
	return znak;
}

void bufor2_analizakodowania(int kodowanie)
{
	cout << "Mozliwe znalezione kodowania:" << endl;
	if (kodowanie & ISO8859)
		cout << "  ISO-8859-2" << endl;
	if (kodowanie & WIN1250)
		cout << "  WIN1250" << endl;
	if (kodowanie & CP852)
		cout << "  CP852" << endl;
	if (kodowanie & UTF8)
		cout << "  UTF8" << endl;
	if (kodowanie & MAZOVIA)
		cout << "  MAZOVIA" << endl;
	if (!kodowanie)
		cout << "  *** nierozpoznane ***" << endl;
}

int bufor2_jakiekodowanie(BUFOR_CTRL& buforctrl, int rozmiar)
{
	int kod = ISO8859|WIN1250|CP852|UTF8|MAZOVIA;
	BYTE bajt;
	while (!bufor2_eof(buforctrl)) {
		bajt = bufor2_wezbajt(buforctrl);
		if (rozmiar>=0)
			if (!rozmiar)
				break;
			else
				rozmiar--;
		switch (bajt) {
			case 0xEF:
				bajt = bufor2_wezbajt(buforctrl);
				if (bajt==0xBB) {
					bajt = bufor2_wezbajt(buforctrl);
					if (bajt==0xBF) {
						kod &= (UTF8);
						return kod;
					}
				}
				break;
			case 0xAC:
			case 0xB1:
			case 0xB6:
				kod &= (ISO8859);
				break;
			case 0xA1:
			case 0xA6:
				kod &= (ISO8859|MAZOVIA);
				break;
			case 0xA3:
				kod &= (ISO8859|WIN1250|MAZOVIA);
				break;
			case 0xAF:
			case 0xB3:
			case 0xC6:
			case 0xCA:
			case 0xD1:
			case 0xD3:
			case 0xE6:
			case 0xEA:
			case 0xF1:
			case 0xF3:
				kod &= (ISO8859|WIN1250);
				break;
			case 0xA5:
				kod &= (WIN1250|CP852|MAZOVIA);
				break;
			case 0x8C:
			case 0x9F:
			case 0xB9:
				kod &= (WIN1250);
				break;
			case 0x9C:
				kod &= (WIN1250|MAZOVIA);
				break;
			case 0x8F:
				kod &= (WIN1250|CP852|MAZOVIA);
				break;
			case 0x88:
			case 0x97:
			case 0x9D:
			case 0xA8:
			case 0xA9:
			case 0xAB:
			case 0xBE:
			case 0xE0:
			case 0xE3:
			case 0xE4:
				kod &= (CP852);
				break;
			case 0x86:
			case 0x8D:
			case 0x98:
			case 0xA2:
			case 0xA4:
			case 0xBD:
				kod &= (CP852|MAZOVIA);
				break;
			case 0x90:
			case 0x91:
			case 0x92:
			case 0x95:
			case 0x9E:
			case 0xA0:
			case 0xA7:
				kod &= (MAZOVIA);
				break;
		}
	}
	return kod;
}

void bufor2_przekodujplik(void)
{
	string nazwapliku;
	BUFOR_CTRL bufctrl;
	BYTE bajt,mapbajt;
	int kodowanie;
	char znak;
	ofstream output;
	//
	cout << "Przekodowanie pliku z dysku" << endl << endl;
	cout << "Podaj nazwe pliku: "; cin >> nazwapliku;
	if (bufor2_otworz(bufctrl, nazwapliku)) {
		cerr << "Jakis blad pliku: " << bufctrl.nazwapliku << endl;
		return;
	}
	kodowanie = bufor2_jakiekodowanie(bufctrl, -1);
	bufor2_analizakodowania(kodowanie);
	bufor2_napoczatek(bufctrl);
	cout << endl << "Przekoduj na:" << endl;
	cout << "1. ISO8859" << endl;
	cout << "2. WIN1250" << endl;
	cout << "3. CP852" << endl;
	cout << "4. UTF8(nie dziala)" << endl;
	cout << "5. MAZOVIA" << endl;
	output.open("przekodowany.txt", ios::out|ios::binary);
	if (!output) {
		cerr << "B³¹d otwarcia pliku: przekodowany.txt" << endl;
		return;
	}
	cin >> znak;
	cin.get();
	cout << endl;
	while (!bufor2_eof(bufctrl)) {
		bajt = bufor2_wezbajt(bufctrl);
		switch (znak) {
			// na iso8859
			case '1':
				if (kodowanie & ISO8859) {
					// z iso8859 na iso8859
					mapbajt = bajt;
				}
				if (kodowanie & WIN1250) {
					// z win1250 na iso
					mapbajt = map_win12502iso(bajt);
				}
				if (kodowanie & CP852) {
					// z cp852 na iso
					mapbajt = map_cp8522iso(bajt);
				}
				if (kodowanie & MAZOVIA) {
					// z cp852 na mazovia
					mapbajt = map_mazovia2iso(bajt);
				}
				if (!kodowanie) {
					mapbajt = bajt;
				}
				break;
			// na win1250
			case '2':
				if (kodowanie & ISO8859) {
					// z iso8859 na win1250
					mapbajt = map_iso2win1250(bajt);
				}
				if (kodowanie & WIN1250) {
					// z win1250 na win1250
					mapbajt = bajt;
				}
				if (kodowanie & CP852) {
					// z cp852 na win
					mapbajt = map_cp8522win1250(bajt);
                }
				if (kodowanie & MAZOVIA) {
					// z zavowia na win
					mapbajt = map_mazovia2win1250(bajt);
				}
				if (!kodowanie) {
					mapbajt = bajt;
				}
				break;
			// na cp852
			case '3':
				if (kodowanie & ISO8859) {
					// z iso8859 na cp852
					mapbajt = map_iso2cp852(bajt);
				}
				if (kodowanie & WIN1250) {
					// z win1250 na cp852
					mapbajt = map_win12502cp852(bajt);
				}
				if (kodowanie & CP852) {
					// z cp852 na cp852
					mapbajt = bajt;
				}
				if (kodowanie & MAZOVIA) {
					// z zavowia na win
					mapbajt = map_mazovia2cp852(bajt);
                }
				if (!kodowanie) {
					mapbajt = bajt;
				}
				break;
			// na utf8
			case '4':
				break;
			// na mazovia
			case '5':
				if (kodowanie & ISO8859) {
					// z iso8859 na mazovia
					mapbajt = map_iso2mazovia(bajt);
				}
				if (kodowanie & WIN1250) {
					// z win1250 na mazovia
					mapbajt = map_win12502mazovia(bajt);
				}
				if (kodowanie & CP852) {
					// z cp852 na mazovia
					mapbajt = map_cp8522mazovia(bajt);
				}
				if (kodowanie & MAZOVIA) {
					// z mazovia na mazovia
					mapbajt = bajt;
				}
				if (!kodowanie) {
					mapbajt = bajt;
				}
				break;
		} // switch
		output.put(mapbajt);
	}
	output.close();
	bufor2_zamknij(bufctrl);
}

void bufor2_test(void)
{
	BUFOR_CTRL bufctrl;
	BYTE bajt;
	if (bufor2_otworz(bufctrl, "pt1_iso8859.txt")) {
		cerr << "Jakis blad pliku: " << bufctrl.nazwapliku << endl;
		return;
	}
	for(int i=0; i<52000; i++) {
		bajt = bufor2_wezbajt(bufctrl);
		cout << (char)bajt;
		if (bufor2_eof(bufctrl))
			break;
	}
	cout << endl;
	bufor2_zamknij(bufctrl);
};

void przekoduj_plikzdysku(void)
{
	string nazwapliku;
	ifstream input;
	cout << "Przekodowanie pliku" << endl;
	cout << "Nazwa pliku dyskowego:"; cin >> nazwapliku;
	input.open(nazwapliku.c_str(), ios::in|ios::binary|ios::ate);
	if (!input) {
		cerr << "Blad otwarcia pliku: " << nazwapliku << endl;
		return;
	}
}

int main(void)
{
	bufor2_przekodujplik();
	system("pause");
	return 0;
}
